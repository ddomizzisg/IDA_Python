Timer unit: 1e-06 s

Total time: 0.117506 s
File: <ipython-input-53-28756b28a371>
Function: split at line 1

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     1                                           def split(file, n, m): 
     2                                               """
     3                                               Inputs: 
     4                                               file: name of the file to split
     5                                               n   : number of fragments after splitting the file
     6                                               m   : minimum number of fragments required to restore the file
     7                                               Output:
     8                                               fragments as separate files
     9                                               """
    10                                           
    11         1          3.0      3.0      0.0      if m>n: 
    12                                                   raise ValueError("numToAssemble must be less than numFragments")
    13                                               
    14                                               # all computations are done modulo p
    15         1          1.0      1.0      0.0      p = 257 
    16                                               
    17                                               # create building_blocks where row i is (1,i, i**2, ..., i**(m-1)) for i in [1,n] inlcusive
    18         1       4558.0   4558.0      3.9      building_blocks = np.array(build_building_blocks(m,n,p))
    19                                               
    20                                               # there are n fragments, each fragment is of length len(original_file)/m
    21         1        585.0    585.0      0.5      original_file = open(file, "rb").read()
    22         1          4.0      4.0      0.0      original_file_len = len(original_file)
    23         1        361.0    361.0      0.3      fragment_len = math.ceil(original_file_len/m)
    24         1       2053.0   2053.0      1.7      fragments=np.zeros([n,fragment_len], dtype=np.uint16)
    25                                               
    26                                               # hash value of the original_file is used to check 
    27                                               # if the input "fragments_filenames" to the function "assemble" 
    28                                               # are derived from the same file
    29         1          8.0      8.0      0.0      original_file_hash = hash(original_file)
    30                                               
    31                                               # convert original_file to numpy array
    32         1         38.0     38.0      0.0      original_file=np.frombuffer(original_file, dtype=np.uint8)
    33                                               
    34                                               # the j-th entry of fragment i is the inner product of building_blocks[i] and the
    35                                               # j-th segment of the original file
    36      1459       1136.0      0.8      1.0      for i in range(0,original_file_len,m):
    37      1458       1635.0      1.1      1.4          segment=original_file[i:i+m]
    38                                                   # last segment might need to be padded with zeros
    39      1458       1293.0      0.9      1.1          if len(segment)<m: 
    40         1       2598.0   2598.0      2.2              segment=np.pad(segment, [(0,m-len(segment))], mode='constant')
    41     16038      13140.0      0.8     11.2          for row in range(n):
    42     14580      75147.0      5.2     64.0              fragments[row][i//m]=np.dot(segment, building_blocks[row])%p
    43                                               
    44                                               # write fragments to files  
    45                                               # fragment i is written to the file <original_filename><original_file_hash>_i
    46         1          4.0      4.0      0.0      original_filename = file.split(".")[0]
    47         1          1.0      1.0      0.0      fragment_filehandles={}    
    48         1          1.0      1.0      0.0      fragment_filenames=[]
    49        11         62.0      5.6      0.1      for idx in range(n): 
    50        10         61.0      6.1      0.1          fragment_filename = "{}{}_{}".format(original_filename,original_file_hash,idx )
    51        10         12.0      1.2      0.0          fragment_filenames.append(fragment_filename)
    52        10       1268.0    126.8      1.1          fragment_filehandle = open(fragment_filename,'w')
    53        10         13.0      1.3      0.0          fragment_filehandles[idx]=fragment_filehandle
    54        10       2335.0    233.5      2.0          fragment_content = str(fragments[idx].tolist())
    55                                                   # compute the hash of hash(hash(fragment_content)+hash(original_file)) for error detection
    56        10         58.0      5.8      0.0          fragment_hash = hash(hash(fragment_content)+original_file_hash)
    57                                                   # write identifiers for each file (idx,m,n,p,original_file_hash)
    58        10         47.0      4.7      0.0          fragment_filehandle.write("{} {} {} {} {} {}\n".format(idx, m, n, p,original_file_hash, fragment_hash))
    59        10        689.0     68.9      0.6          fragment_filehandle.write(fragment_content)
    60        10      10394.0   1039.4      8.8          fragment_filehandle.close()
    61         1          1.0      1.0      0.0      return fragment_filenames