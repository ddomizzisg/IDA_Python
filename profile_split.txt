Timer unit: 1e-06 s

Total time: 22.1865 s
File: <ipython-input-95-e1b7bb25fa8d>
Function: split at line 1

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     1                                           def split(file, n, m): 
     2                                               """
     3                                               Inputs: 
     4                                               file: name of the file to split
     5                                               n   : number of fragments after splitting the file
     6                                               m   : minimum number of fragments required to restore the file
     7                                               Output:
     8                                               a list of n fragments (as Fragment objects)
     9                                               """
    10                                           
    11         1          2.0      2.0      0.0      if m>n: 
    12                                                   raise ValueError("numToAssemble must be less than numFragments")
    13                                               
    14                                               # find the prime number greater than n
    15                                               # all computations are done modulo p
    16         1          1.0      1.0      0.0      p = 257 if n<257 else nextPrime(n)
    17                                               
    18                                               # convert file to byte strings
    19         1       2956.0   2956.0      0.0      original_file=open(file, "rb").read()  
    20                                               
    21                                               # split original_file into chunks (subfiles) of length m 
    22         1     555483.0 555483.0      2.5      original_segments=[list(original_file[i:i+m]) for i in range(0,len(original_file),m)]
    23                                               
    24                                               # for the last subfile, if the length is less than m, pad the subfile with zeros 
    25                                               # to achieve final length of m
    26         1          2.0      2.0      0.0      residue = len(original_file)%m
    27         1          1.0      1.0      0.0      if residue:
    28                                                   
    29                                                   last_subfile=original_segments[-1]
    30                                                   last_subfile.extend([0]*(m-residue))
    31                                               
    32                                               
    33         1         43.0     43.0      0.0      building_blocks=build_building_blocks(m,n,p)
    34                                               
    35         1          1.0      1.0      0.0      fragments=[]
    36        11          6.0      0.5      0.0      for i in range(n): 
    37        10          9.0      0.9      0.0          fragment = []
    38   5324840    3231590.0      0.6     14.6          for k in range(len(original_segments)): 
    39   5324830   17667218.0      3.3     79.6              fragment.append(inner_product(building_blocks[i], original_segments[k],p))
    40        10          8.0      0.8      0.0          fragments.append(fragment)
    41                                               
    42                                               
    43                                               # hash value of the original_file is used to check 
    44                                               # if the input "fragments_filenames" to the function "assemble" 
    45                                               # are derived from the same file
    46         1       1362.0   1362.0      0.0      original_file_hash = hash(original_file)
    47                                               
    48                                               # write fragments to files  
    49                                               # fragment i is written to the file <original_filename><original_file_hash>_i
    50         1          5.0      5.0      0.0      original_filename = file.split(".")[0]
    51         1          1.0      1.0      0.0      fragment_filehandles={}    
    52         1          1.0      1.0      0.0      fragment_filenames=[]
    53        11         38.0      3.5      0.0      for idx in range(n): 
    54        10         61.0      6.1      0.0          fragment_filename = "{}{}_{}".format(original_filename,original_file_hash,idx )
    55        10         17.0      1.7      0.0          fragment_filenames.append(fragment_filename)
    56        10      10487.0   1048.7      0.0          fragment_filehandle = open(fragment_filename,'w')
    57        10         23.0      2.3      0.0          fragment_filehandles[idx]=fragment_filehandle
    58        10     637717.0  63771.7      2.9          fragment_content = str(fragments[idx])
    59                                                   # compute the hash of hash(hash(fragment_content)+hash(original_file)) for error detection
    60        10      14200.0   1420.0      0.1          fragment_hash = hash(hash(fragment_content)+original_file_hash)
    61                                                   # write identifiers for each file (idx,m,n,p,original_file_hash)
    62        10        106.0     10.6      0.0          fragment_filehandle.write("{} {} {} {} {} {}\n".format(idx, m, n, p,original_file_hash, fragment_hash))
    63        10      48070.0   4807.0      0.2          fragment_filehandle.write(fragment_content)
    64        10      17130.0   1713.0      0.1          fragment_filehandle.close()
    65         1          1.0      1.0      0.0      return fragment_filenames