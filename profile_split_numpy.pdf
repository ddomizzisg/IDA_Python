Timer unit: 1e-06 s

Total time: 566.924 s
File: <ipython-input-53-28756b28a371>
Function: split at line 1

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     1                                           def split(file, n, m): 
     2                                               """
     3                                               Inputs: 
     4                                               file: name of the file to split
     5                                               n   : number of fragments after splitting the file
     6                                               m   : minimum number of fragments required to restore the file
     7                                               Output:
     8                                               fragments as separate files
     9                                               """
    10                                           
    11         1          2.0      2.0      0.0      if m>n: 
    12                                                   raise ValueError("numToAssemble must be less than numFragments")
    13                                               
    14                                               # all computations are done modulo p
    15         1          1.0      1.0      0.0      p = 257 
    16                                               
    17                                               # create building_blocks where row i is (1,i, i**2, ..., i**(m-1)) for i in [1,n] inlcusive
    18         1        235.0    235.0      0.0      building_blocks = np.array(build_building_blocks(m,n,p))
    19                                               
    20                                               # there are n fragments, each fragment is of length len(original_file)/m
    21         1     242435.0 242435.0      0.0      original_file = open(file, "rb").read()
    22         1          5.0      5.0      0.0      original_file_len = len(original_file)
    23         1         30.0     30.0      0.0      fragment_len = math.ceil(original_file_len/m)
    24         1        230.0    230.0      0.0      fragments=np.zeros([n,fragment_len], dtype=np.uint16)
    25                                               
    26                                               # hash value of the original_file is used to check 
    27                                               # if the input "fragments_filenames" to the function "assemble" 
    28                                               # are derived from the same file
    29         1      35879.0  35879.0      0.0      original_file_hash = hash(original_file)
    30                                               
    31                                               # convert original_file to numpy array
    32         1        166.0    166.0      0.0      original_file=np.frombuffer(original_file, dtype=np.uint8)
    33                                               
    34                                               # the j-th entry of fragment i is the inner product of building_blocks[i] and the
    35                                               # j-th segment of the original file
    36   5186482    3010373.0      0.6      0.5      for i in range(0,original_file_len,m):
    37   5186482    5050403.0      1.0      0.9          segment=original_file[i:i+m]
    38                                                   # last segment might need to be padded with zeros
    39   5186482    4011791.0      0.8      0.7          if len(segment)<m: 
    40                                                       segment=np.pad(segment, [(0,m-len(segment))], mode='constant')
    41  57051294   39128765.0      0.7      6.9          for row in range(n):
    42  51864813  515444115.0      9.9     90.9              fragments[row][i//m]=np.dot(segment, building_blocks[row])%p
    43                                               
    44                                               # write fragments to files  
    45                                               # fragment i is written to the file <original_filename><original_file_hash>_i
    46                                               original_filename = file.split(".")[0]
    47                                               fragment_filehandles={}    
    48                                               fragment_filenames=[]
    49                                               for idx in range(n): 
    50                                                   fragment_filename = "{}{}_{}".format(original_filename,original_file_hash,idx )
    51                                                   fragment_filenames.append(fragment_filename)
    52                                                   fragment_filehandle = open(fragment_filename,'w')
    53                                                   fragment_filehandles[idx]=fragment_filehandle
    54                                                   fragment_content = str(fragments[idx].tolist())
    55                                                   # compute the hash of hash(hash(fragment_content)+hash(original_file)) for error detection
    56                                                   fragment_hash = hash(hash(fragment_content)+original_file_hash)
    57                                                   # write identifiers for each file (idx,m,n,p,original_file_hash)
    58                                                   fragment_filehandle.write("{} {} {} {} {} {}\n".format(idx, m, n, p,original_file_hash, fragment_hash))
    59                                                   fragment_filehandle.write(fragment_content)
    60                                                   fragment_filehandle.close()
    61                                               return fragment_filenames